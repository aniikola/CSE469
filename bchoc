#!/usr/bin/env python3

import struct
from os import getenv
import argparse
from typing import *
from dataclasses import dataclass
from enum import Enum
from datetime import datetime, timezone

STRUCT_FORMAT: str = "32s d 16s I 12s I"
BLOCK_SIZE: int = struct.calcsize(STRUCT_FORMAT)

class BlockState(Enum):
    INITIAL: int    = 0
    CHECKEDIN: int  = 1
    CHECKEDOUT: int = 2
    DISPOSED: int   = 3
    DESTROYED: int  = 4
    RELEASED: int   = 5
    NOSTATE: int    = 6


@dataclass
class BlockData:
    previousHash: str = "\x00"*32
    timestamp: float = 0.0
    caseID: str = "\x00"*16
    evidenceID: int = 0
    state: BlockState = BlockState.NOSTATE
    dataLength: int = 0
    data: str = ""


class Block:
    def __init__(self, data: BlockData = None):
        self.data: BlockData = data if (data is not None) else BlockData
        self.next: Block = None


listHead: Block = None

def doAdd(args: argparse.Namespace):
    itemSet: Set[int] = set(args.itemIDs)
    if (len(itemSet) < len(args.itemIDs)):
        print("Duplicate input ID")
        exit(-1)

    prevBlock: Block = None
    currBlock: Block = listHead
    while (currBlock is not None):
        currID: int = currBlock.data.itemID
        if (currID in itemSet):
            print("Duplicate input ID")
            exit(-1)
        
        prevBlock = currBlock
        currBlock = currBlock.next
    
    for newBlockID in args.itemsIDs:
        newBlockData: BlockData = BlockData()

        newBlockData.state = BlockData.CHECKEDIN
        newBlockData.caseID = args.caseID
        newBlockData.itemID = newBlockID


    


def doCheckout(args: argparse.Namespace):
    pass


def doCheckin(args: argparse.Namespace):
    pass


def doLog(args: argparse.Namespace):
    pass


def doRemove(args: argparse.Namespace):
    pass


def doInit(args: argparse.Namespace):
    saveFilePath: str = getenv("BCHOC_FILE_PATH")
    if (saveFilePath is not None): 
        print("Blockchain file found with INITIAL block.")
        return loadChainFromFile(saveFilePath)
    
    initialData: BlockData = BlockData()
    initialData.previousHash = ""
    initialData.timestamp = datetime.now(timezone.utc).timestamp()
    initialData.caseID = ""
    initialData.evidenceID = 0
    initialData.state = BlockState.INITIAL
    initialData.dataLength = 14
    initialData.data = "Initial block\x00"

    listHead: Block = Block(initialData)

    print("Blockchain file not found. Created INITIAL block.")


def doVerify(args: argparse.Namespace):
    pass


def loadChainFromFile(filePath):
    pass


def main() -> None:
    modes: List[str] = ["add", "checkout", "checkin", "log", "remove", "init", "verify"]

    argumentParser: argparse.ArgumentParser = argparse.ArgumentParser()
    subparsers = argumentParser.add_subparsers(dest="mode")

    modeParsers: Dict[str, Any] = {
        mode: subparsers.add_parser(mode) for mode in modes
    }

    modeParsers["add"].add_argument("-c", "--case_id", dest="caseID", type=str, required=True)
    modeParsers["add"].add_argument("-i", "--item_id", dest="itemIDs", type=int, required=True, action="append")

    modeParsers["checkout"].add_argument("-i", "--item_id", dest="itemID", type=int, required=True)

    modeParsers["checkin"].add_argument("-i", "--item_id", dest="itemID", type=int, required=True)

    modeParsers["log"].add_argument("-r", "--reversed", dest="reversed", action="store_true")
    modeParsers["log"].add_argument("-n", "--num_entries", dest="numEntries", type=int)
    modeParsers["log"].add_argument("-c", "--case_id", dest="caseID", type=str)
    modeParsers["log"].add_argument("-i", "--item_id", dest="itemID", type=int)
    
    modeParsers["remove"].add_argument("-i", "--item_id", dest="itemID", type=int, required=True)
    modeParsers["remove"].add_argument("-y", "--reason", dest="reason", type=str, required=True)
    modeParsers["remove"].add_argument("-o", "--owner", dest="owner", type=str)

    args: argparse.Namespace = argumentParser.parse_args()

    modeFunctionName: str = f"do{args.mode.capitalize()}"
    globalVals: Dict[str, Any] = globals()
    if (modeFunctionName not in globalVals):
        print(f'Function "{modeFunctionName}" not implemented')
        exit(-1)
    
    globalVals[modeFunctionName](args)


if __name__ == '__main__':
    main()